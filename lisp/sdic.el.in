;;; sdic.el ---- major mode to view dictionary
;;; $Id$

;;; Author: Tsuchiya Masatoshi <tsuchiya@pine.kuee.kyoto-u.ac.jp>
;;; Keywords: dictionary

;;; Commentary:

;; 英和/和英辞書を閲覧する目的で作成した major mode です。
;; 利用及び再配布の際は、GNU 一般公用許諾書の適当なバージョンにしたがっ
;; て下さい。

;; 一次配布元
;;    http://www-nagao.kuee.kyoto-u.ac.jp/member/tsuchiya/elisp/sdic.html


;;; ※※※ 注意 ※※※

;; このプログラムは、まだ作成されたばかりですので、これから多数の変更
;; が出ると思われます。注意して使ってください。
;;
;; また、こんな機能が欲しいとか、動作が希望と違うなど、要望があれば遠
;; 慮なく連絡してください。出来るだけ対応したいと思います。


;;; Install:

;; (1) sdic.el, sdic-sgml.el, sdic-grep.el, sdic-array.el,
;;     sdic-compat.el, sdic-gene.el と stem.el を適当な場所に保存して、
;;     必要ならバイトコンパイルして下さい。
;;
;;
;; (2) sdic-sgml.el, sdic-grep.el, sdic-array.el, sdic-compat.el,
;;     sdic-gene.el は辞書を検索するためのライブラリです。これらのライ
;;     ブラリのどれかを使って辞書を検索できるようにして下さい。詳細に
;;     ついては、README とそれぞれのソースファイルを参照。
;;
;;
;; (3) 使えるようにした辞書のリストを、sdic-eiwa-dictionary-list およ
;;     び sdic-waei-dictionary-list に設定します。例えば、英和辞書
;;     /usr/dict/gene.dic を sdic-grep.el を使って検索する場合は次のよ
;;     うになります。
;;
;;         (setq sdic-eiwa-dictionary-list '((sdic-grep "/usr/dict/gene.dic")))
;;
;;     複数の辞書を同時に検索することも出来ます。
;;
;;         (setq sdic-waei-dictionary-list '((sdic-array "~/data/edict")
;;                                           (sdic-comat "/usr/dict/jgene.dic")))
;;
;;     辞書を利用しない場合は nil を代入して下さい。また、これらの設定
;;     は ~/.emacs などの適切な場所に書き込んで下さい。
;;
;;
;; (4) ~/.emacs に次のようなコードを挿入します。
;;
;;         (autoload 'sdic-describe-word "sdic" "英単語の意味を調べる" t nil)
;;         (global-set-key "\C-cw" 'sdic-describe-word)
;;
;;     好みに合わせて適当にキーバインドは変更して下さい。


;;; Note:

;; 検索結果の表示の仕方や動作を制御する変数があります。詳細については、
;; 下の source を参照して下さい。
;;
;; grep / array などの外部コマンドを利用して辞書検索する場合は、それら
;; の外部コマンドが対応している漢字コードを設定して、辞書もその漢字コー
;; ドに合わせる必要があります。その場合、日本語 EUC がおそらく一番安全
;; でしょう。
;;
;; Emacs20 で使う場合は、
;;
;;     (set-language-environment "Japanese")
;;     (set-terminal-coding-system 'euc-japan)
;;
;; と .emacs に設定されているか確認してください。
;;
;; XEmacs で使う場合は、
;;
;;     (set-language-environment "Japanese")
;;     (set-default-coding-systems 'euc-japan)
;;
;; と .emacs に設定されているか確認してください。


(provide 'sdic)
(require 'sdic-sgml)
(require 'stem)
(eval-when-compile
  (require 'sdic-grep)
  (require 'sdic-compat))


;;;----------------------------------------------------------------------
;;;		カスタマイズ用変数
;;;----------------------------------------------------------------------

(defvar sdic-left-margin 2 "*Left margin of contents.
説明文の左側の余白幅")

(defvar sdic-fill-column default-fill-column "*Right edge of contents.
説明文を整形する幅")

(defvar sdic-window-height 10 "*Height of window to show entrys and contents.
検索結果表示ウインドウの高さ")

(defvar sdic-warning-hidden-entry t "*If non-nil, warning of hidden entries is enable.
nil 以外が設定されている場合、検索結果表示ウインドウに表示しきれなかった情報があれば警告する")

(defvar sdic-disable-select-window nil "*Option to disable to select other window.
検索結果表示ウインドウにカーソルを移動しないようにする場合は nil 以外を設定する")

(defvar sdic-face-style 'bold  "*Style of entry.
見出し語を表示するために使う装飾形式")

(defvar sdic-face-color "black" "*Color of entry.
見出し語を表示するために使う色")

(defvar sdic-disable-vi-key nil "*Option to disable some key.
辞書閲覧に vi ライクのキーを使わない場合は nil 以外を設定する")

(defvar sdic-eiwa-dictionary-list
  (let ((file "~/usr/dict/gene.sdic"))
    (and (file-readable-p (expand-file-name file))
	 (list (list (if (string-match "\\.sdic$" file)
			 (if (and (require 'sdic-grep)
				  (sdic-grep-available-p))
			     'sdic-grep
			   'sdic-gene)
		       (if (and (require 'sdic-compat)
				(sdic-compat-available-p))
			   'sdic-compat
			 'sdic-gene))
		     file)))) "\
*Options of an English-Japanese dictionary.
英和辞典の検索メソッドのリストを指定する変数")

(defvar sdic-waei-dictionary-list
  (let ((file "~/usr/dict/edict.sdic"))
    (and (file-readable-p (expand-file-name file))
	 (list (list (if (string-match "\\.sdic$" file)
			 (if (and (require 'sdic-grep)
				  (sdic-grep-available-p))
			     'sdic-grep
			   'sdic-gene)
		       (if (and (require 'sdic-compat)
				(sdic-compat-available-p))
			   'sdic-compat
			 'sdic-gene))
		     file
		     '(add-keys-to-headword t))))) "\
*Options of an English-Japanese dictionary.
和英辞典の検索メソッドのリストを指定する変数")

(defvar sdic-default-coding-system
  (if (>= emacs-major-version 20)
      (if (string-match "XEmacs" emacs-version)
	  (cond
	   ((member 'euc-japan-unix (coding-system-list)) 'euc-japan-unix)
	   ((member 'euc-jp-unix (coding-system-list)) 'euc-jp-unix)
	   (t 'euc-japan))
	'euc-japan-unix)
    *euc-japan*unix)
  "*Default coding-system for sdic and libraries.")




;;;----------------------------------------------------------------------
;;;		内部変数
;;;----------------------------------------------------------------------

(defvar sdic-english-prep-list '("at" "by" "for" "in" "on" "of" "with" "as" "before" "after") "\
List of English prepositions
英語の前置詞のリスト")

(defvar sdic-english-prep-regexp
  (format "\\(%s\\)\\b" (mapconcat 'regexp-quote sdic-english-prep-list "\\|")) "\
Regexp of Englist prepositions
英語の前置詞とマッチする正規表現")

(defvar sdic-eiwa-symbol-list nil "英和辞典のシンボル")
(defvar sdic-waei-symbol-list nil "和英辞典のシンボル")
(defvar sdic-buffer-start-point nil "検索結果表示バッファの表示開始ポイント")
(defvar sdic-mode-map nil "Keymap of sdic-mode")
(defconst sdic-version "2.0pre1")
(defconst sdic-buffer-name "*sdic*" "検索結果表示バッファの名前")
(defconst sdic-mode-name "SDIC" "検索結果を表示するバッファの major mode")




;;;----------------------------------------------------------------------
;;;		検索メソッドを呼び出す関数
;;;----------------------------------------------------------------------

(defun sdic-init-dictionary (option-list) "\
Function to initialize dictionary.
指定された辞書と関連付けられている検索ライブラリを初期化する関数"
  (let (dic)
    (and option-list
	 (listp option-list)
	 (require (car option-list))
	 (setq dic (apply (get (car option-list) 'init-dictionary) (cdr option-list)))
	 (sdic-dictionary-symbol-p dic)
	 (put dic 'search-method (car option-list))
	 dic)))


(defun sdic-open-dictionary (dic) "\
Function to open dictionary.
指定された辞書を検索できるようにする関数"
  (and (sdic-dictionary-symbol-p dic)
       (funcall (get (get dic 'search-method) 'open-dictionary) dic)))


(defun sdic-close-dictionary (dic) "\
Function to close dictionary.
指定された辞書と関連付けられている検索ライブラリを終了する関数"
  (and (sdic-dictionary-symbol-p dic)
       (funcall (get (get dic 'search-method) 'close-dictionary) dic)))


(defun sdic-search-entry (dic word &optional search-type) "\
Function to search word in dictionary.
指定された辞書を検索する関数
見出し語、辞書シンボル、見出し語のIDからなる配列を要素とする配列を返す。"
  (mapcar (function
	   (lambda (c)
	     (list (car c) dic (cdr c))))
	  (funcall (get (get dic 'search-method) 'search-entry) dic word search-type)))


(defun sdic-sort-dictionary-order (entry-list) "\
Function to sort entry list in dictionary order.
見出し語、辞書シンボル、見出し語のIDからなる配列を要素とする配列 
ENTRY-LIST を、見出し語の辞書順に並べ替える関数。"
  (mapcar 'cdr
	  (sort (mapcar (function
			 (lambda (entry)
			   (if (string-match "\\Ca" (car entry))
			       (cons (concat (car entry) "\^@") entry)
			     (cons (concat (sdic-sgml-replace-string (downcase (car entry)) "[^A-z0-9]+" " ")
					   "\^@" (car entry) "\^@")
				   entry))))
			entry-list)
		(function (lambda (a b) (string< (car a) (car b)))))))


(defun sdic-search-multi-dictionaries (dic-list word &optional search-type) "\
Function to search word in multi dictionaries.
指定されている複数の辞書を串刺検索する関数
見出し語、辞書シンボル、見出し語のIDからなる配列を要素とする配列を返す。"
  (sdic-sort-dictionary-order
   (apply 'append
	  (mapcar (function
		   (lambda (dic)
		     (sdic-search-entry dic word search-type)))
		  dic-list))))


(defun sdic-get-content (dic id) "\
Function to get content.
指定されている辞書から定義文を読み出す関数"
  (funcall (get (get dic 'search-method) 'get-content) dic id))


(defun sdic-buffer-live-p (buffer)
  (and (bufferp buffer) (buffer-name buffer) buffer))


(defun sdic-make-dictionary-symbol ()
  (make-symbol "sdic-dictionary"))


(defun sdic-dictionary-symbol-p (symbol)
  (equal (symbol-name symbol) "sdic-dictionary"))




;;;----------------------------------------------------------------------
;;;		内部関数
;;;----------------------------------------------------------------------

(defvar sdic-left-margin-ignored-by-fill-region (string-match "^19\\.28" emacs-version) "\
fill-region 関数が left-margin の設定を無視する場合は nil 以外を設定する")
(defsubst sdic-fill-region (start end) "\
Standarized fill-region.
fill-region の Emacs のバージョンによって異なる動作を標準化する関数"
  (save-match-data
    (if sdic-left-margin-ignored-by-fill-region
	;; Emacs-19.28 附属の fill-region は、left-margin を無視するので強制的に indent する
	(let ((fill-column (- fill-column sdic-left-margin)))
	  (fill-region start end)
	  (indent-region start (point) sdic-left-margin))
      (fill-region start end))
    ;; 余分な空行を削除する
    (delete-region (point) (progn (skip-chars-backward " \t\n") (point)))))


(defsubst sdic-insert-content (word content)
  "見出し語と定義文を整形しながら挿入する関数"
  (sdic-overlay-put (sdic-make-overlay (point) (progn (insert word) (point))) 'face 'sdic-face)
  (insert "\n")
  (let ((str "")
	(pos 0)
	(start (point)))
    (while (string-match ",\\([^ ]\\)" content pos)
      (setq str (concat str (substring content pos (match-beginning 0)) ", ")
	    pos (match-beginning 1)))
    (setq content (concat str (substring content pos))
	  str ""
	  pos 0)
    (while (string-match "[^ 0-9]\\(/\\)[^ 0-9]" content pos)
      (setq str (concat str (substring content pos (match-beginning 1)) " / ")
	    pos (match-end 1)))
    (insert str (substring content pos))
    (if (> (+ (current-column) left-margin) fill-column)
	(sdic-fill-region start (point))
      (beginning-of-line)
      (insert (make-string left-margin ? ))
      (end-of-line)))
  (insert "\n"))


;; 検索形式を判別するマクロ
(put 'sdic-decide-query-type 'lisp-indent-function 2)
(defmacro sdic-decide-query-type (dic-list query &rest sexp) "\
QUERY から検索形式を判定して複数の辞書 DIC-LIST を検索するマクロ

QUERY に検索形式を指定する構造が含まれていない場合は、default の動作と
して SEXP を評価する。通常の検索の場合は、検索された見出し語のリストを
返す。"
  (` (cond
      ;; 検索語が '' で囲まれている場合 -> 完全一致検索
      ((and (equal ?' (string-to-char (, query)))
	    (equal "'" (substring (, query) -1)))
       (mapcar (function
		(lambda (entry)
		  (sdic-insert-content (car entry) (sdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (sdic-search-multi-dictionaries (, dic-list) (substring (, query) 1 -1) 'lambda)))
      ;; 検索語の先頭に / がある場合 -> 全文検索
      ((equal ?/ (string-to-char (, query)))
       (mapcar (function
		(lambda (entry)
		  (sdic-insert-content (car entry) (sdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (sdic-search-multi-dictionaries (, dic-list) (substring (, query) 1) 0)))
      ;; 検索語の先頭に * がある場合 -> 後方一致検索
      ((equal ?* (string-to-char (, query)))
       (mapcar (function
		(lambda (entry)
		  (sdic-insert-content (car entry) (sdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (sdic-search-multi-dictionaries (, dic-list) (substring (, query) 1) t)))
      ;; 検索語の末尾に * がある場合 -> 前方一致検索
      ((equal "*" (substring (, query) -1))
       (mapcar (function
		(lambda (entry)
		  (sdic-insert-content (car entry) (sdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (sdic-search-multi-dictionaries (, dic-list) (substring (, query) 0 -1))))
      ;; 特に指定がない場合 -> 指定された S 式を評価
      (t
       (,@ sexp)))))


;; 英和辞典を検索する関数
(defun sdic-search-eiwa-dictionary (query)
  (sdic-decide-query-type sdic-eiwa-symbol-list query
    (let (word-list stem-list orig pat point str)
      (setq word-list (sdic-split-string (downcase query)))
      (prog1 (mapcar
	      (function
	       (lambda (entry)
		 (and (not point)
		      (string-match pat (car entry))
		      (setq point (point)))
		 (sdic-insert-content (car entry) (sdic-get-content (nth 1 entry) (nth 2 entry)))
		 (car entry)))
	      (prog1 (or
		      ;; (1) 不規則変化動詞を検索する
		      (and
		       (setq stem-list (copy-sequence (assoc (car word-list) stem:irregular-verb-alist)))
		       (sdic-sort-dictionary-order
			(apply 'append
			       (mapcar
				(function
				 (lambda (word)
				   (setq pat (format "^\\(%s$\\|%s \\)"
						     (regexp-quote word) (regexp-quote word)))
				   (delq nil
					 (mapcar
					  (function
					   (lambda (entry)
					     (and (string-match pat (car entry))
						  (or orig (setq orig word))
						  entry)))
					  (apply 'append
						 (mapcar
						  (function
						   (lambda (dic)
						     (sdic-search-entry dic word)))
						  sdic-eiwa-symbol-list))))))
				stem-list))))
		      ;; (2) 不規則変化動詞を無視した stemming を行なって検索する
		      (progn
			(setq stem-list (let ((stem:irregular-verb-alist nil))
					  (stem:stripping-suffix (car word-list))))
			;; 最長部分列を求める
			(setq pat (let* ((w1 (car stem-list))
					 (w2 (car (reverse stem-list)))
					 (i (min (length w1) (length w2))))
				    (while (not (string= (substring w1 0 i)
							 (substring w2 0 i)))
				      (setq i (1- i)))
				    (substring w1 0 i)))
			(delq nil (mapcar
				   (function
				    (lambda (entry)
				      (if (string-match pat (car entry)) entry)))
				   (prog1 (mapcar
					   (function
					    (lambda (entry)
					      ;; 検索結果から原形と推定される見出し語を検索
					      (setq str (downcase (car entry)))
					      (and (member str stem-list)
						   (not (member str orig))
						   (setq orig (cons str orig)))
					      entry))
					   (sdic-search-multi-dictionaries sdic-eiwa-symbol-list pat))
				     (if orig
					 (setq stem-list (copy-sequence orig)
					       orig (if (member (car word-list) orig)
							(car word-list)
						      (car (sort orig (function
								       (lambda (a b) (> (length a) (length b)))))))
					       pat (format "^\\(%s\\)"
							   (mapconcat (function
								       (lambda (w)
									 (format "%s$\\|%s "
										 (regexp-quote w)
										 (regexp-quote w))))
								      stem-list "\\|")))
				       (setq orig pat
					     pat (concat "^" (regexp-quote pat)))
				       (message "Can't find original form of \"%s\""
						(car word-list))
				       ))))))
		(setq pat (if (nth 1 word-list)
			      (concat "^\\("
				      (mapconcat (function
						  (lambda (w)
						    (format "%s +%s$\\|%s +%s "
							    (regexp-quote w)
							    (regexp-quote (nth 1 word-list))
							    (regexp-quote w)
							    (regexp-quote (nth 1 word-list)))))
						 stem-list "\\|")
				      (if (string= orig (car word-list))
					  "\\)"
					(format "\\|%s\\)" (regexp-quote orig))))
			    (format "^%s$" (regexp-quote orig))))))
	(if point (setq sdic-buffer-start-point point))))))


;; 和英辞典を検索する関数
(defun sdic-search-waei-dictionary (query)
  (sdic-decide-query-type sdic-waei-symbol-list query
    ;; 特に指定がない場合 -> 前方一致検索
    (mapcar (function
	     (lambda (entry)
	       (sdic-insert-content (car entry) (sdic-get-content (nth 1 entry) (nth 2 entry)))
	       (car entry)))
	    (sdic-search-multi-dictionaries sdic-waei-symbol-list query))))




;;;----------------------------------------------------------------------
;;;		本体
;;;----------------------------------------------------------------------

(defun sdic-word-at-point () "\
カーソル位置の単語を返す関数"
  (save-excursion
    (if (not (looking-at "\\<")) (forward-word -1))
    (downcase
     (if (looking-at sdic-english-prep-regexp)
	 (buffer-substring (progn (forward-word -1) (point)) (progn (forward-word 2) (point)))
       (buffer-substring (point) (progn (forward-word 1) (point)))))))


(defvar sdic-read-minibuffer-history '() "\
sdic-read-from-minibuffer 関数のヒストリ")
(defun sdic-read-from-minibuffer (&optional prompt init) "\
ミニバッファから単語を読みとる関数"
  (or init (setq init (or (sdic-word-at-point) "")))
  (setq sdic-read-minibuffer-history
	(cons init sdic-read-minibuffer-history))
  (downcase (read-from-minibuffer (or prompt "Input word : ") init
				  nil nil '(sdic-read-minibuffer-history . 1))))


(defun sdic-select-search-function ()
  "検索関数を選ぶ"
  (message "辞書を選んで下さい: E)英和 J)和英")
  (let ((sw (selected-window))
	(c (read-char)))
    (select-window sw)
    (cond
     ((or (= c ?e) (= c ?E)) 'sdic-search-eiwa-dictionary)
     ((or (= c ?j) (= c ?J)) 'sdic-search-waei-dictionary)
     (t (sdic-select-search-function)))))


;; 単語を辞書で調べる関数
(defun sdic-describe-word (word &optional search-function)
  "Display the meaning of word."
  (interactive
   (let ((f (if current-prefix-arg (sdic-select-search-function)))
	 (w (sdic-read-from-minibuffer)))
     (list w f)))
  (and (interactive-p)
       (< (length word) 2)
       (setq word (sdic-read-from-minibuffer
		   (format "\"%s\" is too short word. Input word again : " word)
		   word)))
  (set-buffer (get-buffer-create sdic-buffer-name))
  (or (string= mode-name sdic-mode-name) (sdic-mode))
  (setq buffer-read-only nil)
  (erase-buffer)
  (let ((case-fold-search t)
	(sdic-buffer-start-point (point-min)))
    (if (prog1 (funcall (or search-function
			    (if (string-match "\\cj" word)
				'sdic-search-waei-dictionary
			      'sdic-search-eiwa-dictionary))
			word)
	  (setq buffer-read-only t)
	  (set-buffer-modified-p nil))
	(sdic-display-buffer sdic-buffer-start-point)
      (message "Can't find word, \"%s\"." word)
      nil)))


;; 主関数の宣言
(defalias 'sdic 'sdic-describe-word)


(defun sdic-describe-region (start end &optional search-function)
  "Display the meaning of pattern."
  (interactive
   (list (region-beginning)
	 (region-end)
	 (if current-prefix-arg (sdic-select-search-function))))
  (sdic-describe-word (buffer-substring start end) search-function))


(defun sdic-describe-word-at-point ()
  "Display the meaning of word at point in Japanese."
  (interactive)
  (let ((orig-table (copy-syntax-table))
	word)
    (unwind-protect
	(progn
	  (modify-syntax-entry ?* "w")
	  (modify-syntax-entry ?' "w")
	  (modify-syntax-entry ?/ "w")
	  (setq word (or (sdic-word-at-point) (sdic-read-from-minibuffer))))
      (set-syntax-table orig-table))
    (or (sdic-describe-word word)
	(sdic-describe-word (sdic-read-from-minibuffer
			     (format "Can't find word \"%s\". Input word again : " word) word)))))


;;; 次の項目に移動する関数
(defun sdic-forward-item ()
  "Move point to the next item."
  (interactive)
  (let ((o))
    (goto-char (sdic-next-overlay-change
		(if (setq o (car (sdic-overlays-at (point))))
		    (sdic-overlay-end o)
		  (point))))))


;;; 前の項目に移動する関数
(defun sdic-backward-item ()
  "Move point to the previous item."
  (interactive)
  (let ((o))
    (goto-char (sdic-previous-overlay-change
		(sdic-previous-overlay-change
		 (if (setq o (car (sdic-overlays-at (point))))
		     (sdic-overlay-start o)
		   (sdic-previous-overlay-change (sdic-previous-overlay-change (point)))))))))


(defun sdic-goto-point-min () "\
バッファの先頭に移動する関数"
  (interactive)
  (goto-char (point-min)))


(defun sdic-goto-point-max () "\
バッファの末尾に移動する関数"
  (interactive)
  (goto-char (point-max)))


(defun sdic-display-buffer (&optional start-point) "\
検索結果表示バッファを表示する関数"
  (let ((old-buffer (current-buffer)))
    (unwind-protect
	(let* ((buf (set-buffer sdic-buffer-name))
	       (w1 (selected-window))
	       (w2 (get-buffer-window buf))
	       (p (or start-point (point)))
	       (h sdic-window-height))
	  (if w2 (progn (select-window w2) (setq h (window-height w2)))
	    (setq w2 (select-window (if (one-window-p)
					(split-window w1 (- (window-height) h))
				      (next-window))))
	    (set-window-buffer w2 buf))
	  (set-window-start w2 p)
	  (and sdic-warning-hidden-entry
	       (> p (point-min))
	       (message "この前にもエントリがあります。"))
	  (goto-char p)
	  (if sdic-disable-select-window (select-window w1))
	  (buffer-size))
      (set-buffer old-buffer))))


(defun sdic-other-window () "\
検索表示バッファから元のバッファに戻る関数"
  (interactive)
  (let ((w (selected-window)))
    (if (and (string= (buffer-name (window-buffer w))
		      sdic-buffer-name)
	     (one-window-p))
	(progn
	  (split-window w (- (window-height) sdic-window-height))
	  (set-window-buffer w (other-buffer)))
      (other-window -1))))


(defun sdic-close-window () "\
検索表示バッファを表示しているウインドウを消去する関数"
  (interactive)
  (let ((w (get-buffer-window sdic-buffer-name)))
    (if w
	(cond
	 ((= (window-height w) sdic-window-height)
	  (delete-window w))
	 (t
	  (set-window-buffer w (other-buffer))
	  (select-window (next-window)))
	 ))))


(defun sdic-exit () "\
検索結果表示バッファを削除する関数"
  (interactive)
  (sdic-close-window)
  (kill-buffer sdic-buffer-name)
  (mapcar 'sdic-close-dictionary sdic-eiwa-symbol-list)
  (mapcar 'sdic-close-dictionary sdic-waei-symbol-list)
  (setq sdic-eiwa-symbol-list nil
	sdic-waei-symbol-list nil))


;;; 辞書を閲覧する major-mode
(defun sdic-mode () "\
辞書を閲覧するメジャーモード

次のような形式の文字列を入力することによって検索方式を指定できます。

'word'          完全一致検索
word*           前方一致検索
*word           後方一致検索
/word           全文検索

これら以外の場合は、通常のキーワード検索を行います。


key             binding
---             -------

w               単語を検索する
SPC             スクロールアップ
b               スクロールダウン( BS / Delete キーも使えます )
n               次の項目
TAB             次の項目
p               前の項目
M-TAB           前の項目
o               辞書を閲覧しているウインドウから他のウインドウに移る
q               辞書を閲覧しているウインドウを消す
Q               SDIC を終了する
<               バッファの先頭に移動
>               バッファの終端に移動
?               ヘルプ表示
"
  (kill-all-local-variables)
  (make-local-variable 'fill-column)
  (setq major-mode 'sdic-mode
	mode-name   sdic-mode-name
	fill-column sdic-fill-column
	left-margin sdic-left-margin
	sdic-mode-map (make-keymap))
  ;; キーバインドの設定
  (define-key sdic-mode-map " " 'scroll-up)
  (define-key sdic-mode-map "b" 'scroll-down)
  (define-key sdic-mode-map [backspace] 'scroll-down)
  (define-key sdic-mode-map [delete] 'scroll-down)
  (define-key sdic-mode-map "\C-?" 'scroll-down)
  (define-key sdic-mode-map "n" 'sdic-forward-item)
  (define-key sdic-mode-map "\t" 'sdic-forward-item)
  (define-key sdic-mode-map "p" 'sdic-backward-item)
  (define-key sdic-mode-map "\M-\t" 'sdic-backward-item)
  (define-key sdic-mode-map "o" 'sdic-other-window)
  (define-key sdic-mode-map "q" 'sdic-close-window)
  (define-key sdic-mode-map "Q" 'sdic-exit)
  (define-key sdic-mode-map "w" 'sdic-describe-word)
  (define-key sdic-mode-map "<" 'sdic-goto-point-min)
  (define-key sdic-mode-map ">" 'sdic-goto-point-max)
  (define-key sdic-mode-map "?" 'describe-mode)
  (cond
   ((not sdic-disable-vi-key)
    (define-key sdic-mode-map "h" 'backward-char)
    (define-key sdic-mode-map "j" 'next-line)
    (define-key sdic-mode-map "k" 'previous-line)
    (define-key sdic-mode-map "l" 'forward-char)))
  (use-local-map sdic-mode-map)
  ;; 見出し語の face の設定
  (make-face 'sdic-face)
  (and (or (not (fboundp 'facep))
	   (facep sdic-face-style))
       (copy-face sdic-face-style 'sdic-face))
  (and window-system
       sdic-face-color
       (set-face-foreground 'sdic-face sdic-face-color))
  ;; それぞれの辞書を初期化する
  (or sdic-eiwa-symbol-list
      (setq sdic-eiwa-symbol-list
	    (delq nil (mapcar 'sdic-init-dictionary sdic-eiwa-dictionary-list))))
  (setq sdic-eiwa-symbol-list (delq nil (mapcar 'sdic-open-dictionary sdic-eiwa-symbol-list)))
  (or sdic-waei-symbol-list
      (setq sdic-waei-symbol-list
	    (delq nil (mapcar 'sdic-init-dictionary sdic-waei-dictionary-list))))
  (setq sdic-waei-symbol-list (delq nil (mapcar 'sdic-open-dictionary sdic-waei-symbol-list)))
  (run-hooks 'sdic-mode-hook))




;;;----------------------------------------------------------------------
;;;		各種 Emacsen の違いを吸収する関数
;;;----------------------------------------------------------------------

(if (fboundp 'next-overlay-change)
    (defalias 'sdic-next-overlay-change 'next-overlay-change)
  ;; XEmacs の場合
  (defun sdic-next-overlay-change (pos) "\
Return the next position after POS where an extent starts or ends.
If there are no more extent boundaries after POS, return (point-max)."
    (catch 'found-next-extent
      (mapcar (function (lambda (ext)
			  (cond
			   ((> (extent-start-position ext) pos)
			    (throw 'found-next-extent (extent-start-position ext)))
			   ((> (extent-end-position ext) pos)
			    (throw 'found-next-extent (extent-end-position ext)))
			   )))
	      (extent-list))
      (point-max))))


(if (fboundp 'previous-overlay-change)
    (defalias 'sdic-previous-overlay-change 'previous-overlay-change)
  (if (fboundp 'extent-list)
      ;; XEmacs の場合
      (defun sdic-previous-overlay-change (pos) "\
Return the previous position before POS where an extent starts or ends.
If there are no more extent boundaries before POS, return (point-min)."
	(catch 'found-previous-extent
	  (mapcar (function (lambda (ext)
			      (cond
			       ((< (extent-end-position ext) pos)
				(throw 'found-previous-extent (extent-end-position ext)))
			       ((< (extent-start-position ext) pos)
				(throw 'found-previous-extent (extent-start-position ext)))
			       )))
		  (reverse (extent-list)))
	  (point-min)))
    ;; Emacs 19.34 以前の場合
    (defun sdic-previous-overlay-change (pos) "\
Return the previous position before POS where an overlay starts or ends.
If there are no more overlay boundaries before POS, return (point-min)."
      (if (> pos (point-max))
	  (error "Specified position is larger than point-max"))
      (save-excursion
	(let (next (prev (point-min)))
	  (while (> pos (setq next (sdic-next-overlay-change prev)))
	    (setq prev next))
	  prev)))))


(if (fboundp 'overlays-at)
    (defalias 'sdic-overlays-at 'overlays-at)
  (defun sdic-overlays-at (pos) "\
Return a list of the extents that contain position POS."
    (delq nil (mapcar (function (lambda (ext)
				  (and (<= (extent-start-position ext) pos)
				       (> (extent-end-position ext) pos)
				       ext)))
		      (extent-list)))))


(if (fboundp 'overlay-put)
    (defalias 'sdic-overlay-put 'overlay-put)
  (defalias 'sdic-overlay-put 'set-extent-property))


(if (fboundp 'make-overlay)
    (defalias 'sdic-make-overlay 'make-overlay)
  (defalias 'sdic-make-overlay 'make-extent))


(if (fboundp 'overlay-start)
    (defalias 'sdic-overlay-start 'overlay-start)
  (defalias 'sdic-overlay-start 'extent-start-position))


(if (fboundp 'overlay-end)
    (defalias 'sdic-overlay-end 'overlay-end)
  (defalias 'sdic-overlay-end 'extent-end-position))


(if (fboundp 'match-string)
    (defalias 'sdic-match-string 'match-string)
  ;; Introduced in Emacs 19.29.
  (defun sdic-match-string (num &optional string) "\
Return string of text matched by last search.
NUM specifies which parenthesized expression in the last regexp.
Value is nil if NUMth pair didn't match, or there were less than NUM pairs.
Zero means the entire text matched by the whole regexp or whole string.
STRING should be given if the last search was by `string-match' on STRING."
    (if (match-beginning num)
	(if string
	    (substring string (match-beginning num) (match-end num))
	  (buffer-substring (match-beginning num) (match-end num))))))


(defun sdic-split-string (string &optional separators) "\
Splits STRING into substrings where there are matches for SEPARATORS.
Each match for SEPARATORS is a splitting point.
The substrings between the splitting points are made into a list
which is returned.
If SEPARATORS is absent, it defaults to \"[ \\f\\t\\n\\r\\v]+\".

If there is match for SEPARATORS at the beginning of STRING, we do not
include a null substring for that.  Likewise, if there is a match
at the end of STRING, we don't include a null substring for that."
  (or separators (setq separators "[ \f\t\n\r\v]+"))
  (let (list (start 0))
    (while (string-match separators string start)
      (or (= start (match-beginning 0))
	  (setq list (cons (substring string start (match-beginning 0)) list)))
      (setq start (match-end 0)))
    (reverse (if (= start (length string)) list (cons (substring string start) list)))))


(defun sdic-insert-file-contents (filename coding-system &optional visit beg end replace)
  (let ((coding-system-for-read coding-system)
	(file-coding-system-for-read coding-system))
    (insert-file-contents filename visit beg end replace)))


(defun sdic-call-process (program &optional infile buffer display coding-system &rest args)
  (let ((coding-system-for-read coding-system)
	(coding-system-for-write coding-system)
	(process-input-coding-system coding-system)
	(process-output-coding-system coding-system)
	(default-process-coding-system (cons coding-system coding-system)))
    (apply 'call-process program infile buffer display args)))


(defun sdic-start-process (name buffer coding-system program &rest args)
  (let ((proc (apply 'start-process name buffer program args)))
    (if (fboundp 'set-process-coding-system)
	(set-process-coding-system proc coding-system coding-system)
      (set-process-input-coding-system proc coding-system)
      (set-process-output-coding-system proc coding-system))
    proc))
