;;; xdic.el ---- major mode to view dictionary
;;; $Id$

;;; Author: Tsuchiya Masatoshi <tsuchiya@pine.kuee.kyoto-u.ac.jp>
;;; Keywords: dictionary

;;; Commentary:

;; 英和辞書を閲覧する目的で作成した major mode です。
;; 利用及び再配布の際は、GNU 一般公用許諾書の適当なバージョンにしたがっ
;; て下さい。

;; 一次配布元
;;    http://www-nagao.kuee.kyoto-u.ac.jp/member/tsuchiya/elisp/xdic.html


;;; ※※※ 注意 ※※※

;; このプログラムは、まだ作成されたばかりですので、これから多数の変更
;; が出ると思われます。注意して使ってください。
;;
;; また、こんな機能が欲しいとか、動作が希望と違うなど、要望があれば遠
;; 慮なく連絡してください。出来るだけ対応したいと思います。


;;; How to Install

;;	(1) xdic.el と stem.el を適当な場所に保存して下さい。必要なら
;;	    バイトコンパイルして下さい。
;;	(2) 辞書を検索するために look を呼び出しています。パスが通って
;;	    いるか確認して下さい。
;;	(3) 辞書を変換して、適当な場所に保存して下さい。
;;	    xdic.el は、辞書のそれぞれのレコードが1つの見出し語と1つの
;;	    説明文からなり、かつ見出し語と説明文がタブで区切られている
;;	    ことを要求します。
;;	(4) .emacs に次のようなコードを挿入します。
;;
;;		(autoload 'xdic-describe-word "xdic" "英単語の意味を調べる" t nil)
;;		(global-set-key "\C-cw" 'xdic-describe-word)
;;
;;	    好みに合わせて適当にキーバインドは変更して下さい。

;; Emacs20 で使う場合は、
;;
;;		(set-language-environment "Japanese")
;;		(set-terminal-coding-system 'euc-japan)
;;
;; と .emacs に設定されているか確認してください。

(provide 'xdic)
(require 'stem)



;;;----------------------------------------------------------------------
;;;		カスタマイズ用変数
;;;----------------------------------------------------------------------

;;; 辞書定義変数

;; 変数 xdic-unix-look-command / xdic-unix-grep-command によって、指定
;; されたコマンドが2つとも見つかった場合は、それらの外部コマンドをを利
;; 用して検索を行います。見つからなかった場合は、Emacs の機能のみを利
;; 用して検索を行いますが、大量のメモリが必要になります。

;; look / grep などの外部コマンドを利用して辞書検索する場合は、それら
;; の外部コマンドが対応している漢字コードを設定して、辞書もその漢字コー
;; ドに合わせる必要があります。その場合、default の日本語 EUC がおそら
;; く一番安全でしょう。

(defvar xdic-eiwa-dictionary-list
  (let ((file (expand-file-name "~/usr/lib/elisp/gene.dic")))
    (if (file-readable-p file)
	(list (list (if (and (require 'xdic-unix) (xdic-unix-available-p))
			'xdic-unix
		      (require 'xdic-gene))
		    file))))
  "*Options of an English-Japanese dictionary.\n英和辞典の検索メソッドを指定する変数")

(defvar xdic-waei-dictionary-list
  (let ((file (expand-file-name "~/usr/lib/elisp/jgene.dic")))
    (if (file-readable-p file)
	(list (list (if (and (require 'xdic-unix) (xdic-unix-available-p))
			'xdic-unix
		      (require 'xdic-gene))
		    file))))
  "*Options of an English-Japanese dictionary.\n和英辞典の検索メソッドを指定する変数")

(defvar xdic-default-coding-system
  (if (>= emacs-major-version 20)
      (if (string-match "XEmacs" emacs-version)
	  (cond
	   ((member 'euc-japan-unix (coding-system-list)) 'euc-japan-unix)
	   ((member 'euc-jp-unix (coding-system-list)) 'euc-jp-unix)
	   (t 'euc-japan))
	'euc-japan-unix)
    *euc-japan*unix)
  "*Default coding-system for xdic and libraries.")


;;; 表示 / 動作制御変数

;; 検索結果の表示や動作を調節するための変数です。さらに細かい調節には 
;; xdic-mode-hook が利用できます。

(defvar xdic-left-margin 2 "*Left margin of contents.
説明文の左側の余白幅")

(defvar xdic-fill-column default-fill-column "*Right edge of contents.
説明文を整形する幅")

(defvar xdic-window-height 10 "*Height of window to show entrys and contents.
検索結果表示ウインドウの高さ")

(defvar xdic-disable-select-window nil "*Option to disable to select other window.
検索結果表示ウインドウにカーソルを移動しないようにする場合は nil 以外を設定する")

(defvar xdic-face-style 'bold  "*Style of entry.
見出し語を表示するために使う装飾形式")

(defvar xdic-face-color "black" "*Color of entry.
見出し語を表示するために使う色")

(defvar xdic-disable-vi-key nil "*Option to disable some key.
辞書閲覧に vi ライクのキーを使わない場合は nil 以外を設定する")


;;; 内部変数

(defvar xdic-english-prep-list '("at" "by" "for" "in" "on" "of" "with") "\
List of English prepositions
英語の前置詞のリスト")

(defvar xdic-english-prep-regexp
  (format "[ \t\r\f\n]+\\(%s\\)$" (mapconcat 'regexp-quote xdic-english-prep-list "\\|")) "\
Regexp of Englist prepositions
英語の前置詞とマッチする正規表現")

(defvar xdic-eiwa-symbol-list nil "英和辞典のシンボル")
(defvar xdic-waei-symbol-list nil "和英辞典のシンボル")
(defvar xdic-mode-map nil "*Keymap of xdic-mode")
(defconst xdic-version "2.0beta1")
(defconst xdic-buffer-name "*xdic*" "検索結果表示バッファの名前")
(defconst xdic-mode-name "Xdic" "検索結果を表示するバッファの major mode")




;;;----------------------------------------------------------------------
;;;		検索メソッドを呼び出す関数
;;;----------------------------------------------------------------------

(defun xdic-init-dictionary (option-list) "\
Function to initialize dictionary.
指定された辞書と関連付けられている検索ライブラリを初期化する関数"
  (let (dic)
    (and option-list
	 (listp option-list)
	 (require (car option-list))
	 (setq dic (apply (get (car option-list) 'init-dictionary) (cdr option-list)))
	 (xdic-dictionary-symbol-p dic)
	 (put dic 'search-method (car option-list))
	 dic)))


(defun xdic-open-dictionary (dic) "\
Function to open dictionary.
指定された辞書を検索できるようにする関数"
  (and (xdic-dictionary-symbol-p dic)
       (funcall (get (get dic 'search-method) 'open-dictionary) dic)))


(defun xdic-close-dictionary (dic) "\
Function to close dictionary.
指定された辞書と関連付けられている検索ライブラリを終了する関数"
  (and (xdic-dictionary-symbol-p dic)
       (funcall (get (get dic 'search-method) 'close-dictionary) dic)))


(defun xdic-search-entry (dic word &optional search-type) "\
Function to search word in dictionary.
指定された辞書を検索する関数
見出し語、辞書シンボル、見出し語のIDからなる配列を要素とする配列を返す。"
  (mapcar (function
	   (lambda (c)
	     (list (car c) dic (cdr c))))
	  (funcall (get (get dic 'search-method) 'search-entry) dic word search-type)))


(defun xdic-get-content (dic id) "\
Function to get content.
指定されている辞書から定義文を読み出す関数"
  (funcall (get (get dic 'search-method) 'get-content) dic id))


(defun xdic-search-multi-dictionaries (dic-list word &optional search-type) "\
Function to search word in multi dictionaries.
指定されている複数の辞書を串刺検索する関数
見出し語、辞書シンボル、見出し語のIDからなる配列を要素とする配列を返す。"
  (sort (apply 'append (mapcar (function
				(lambda (dic)
				  (xdic-search-entry dic word search-type)))
			       dic-list))
	(function (lambda (a b) (string< (car a) (car b))))))


(defun xdic-buffer-live-p (buffer)
  (and (bufferp buffer) (buffer-name buffer) buffer))


(defun xdic-make-dictionary-symbol ()
  (make-symbol "xdic-dictionary"))


(defun xdic-dictionary-symbol-p (symbol)
  (equal (symbol-name symbol) "xdic-dictionary"))




;;;----------------------------------------------------------------------
;;;		内部関数
;;;----------------------------------------------------------------------

(defun xdic-insert-content (word content)
  "見出し語と定義文を整形しながら挿入する関数"
  (xdic-overlay-put (xdic-make-overlay (point) (progn (insert word) (point))) 'face 'xdic-face)
  (insert "\n")
  (save-restriction
    (narrow-to-region (point) (progn (insert content) (point)))
    (goto-char (point-min))
    (while (re-search-forward ",[^ ]" nil t)
      (goto-char (1+ (match-beginning 0)))
      (insert " ")
      (goto-char (match-end 0)))
    (xdic-fill-region (point-min) (goto-char (point-max))))
  (insert "\n"))


;; 検索形式を判別するマクロ
(put 'xdic-decide-query-type 'lisp-indent-function 2)
(defmacro xdic-decide-query-type (dic-list query &rest sexp) "\
QUERY から検索形式を判定して複数の辞書 DIC-LIST を検索するマクロ

QUERY に検索形式を指定する構造が含まれていない場合は、default の動作と
して SEXP を評価する。通常の検索の場合は、検索された見出し語のリストを
返す。"
  (` (cond
      ;; 検索語が '' で囲まれている場合 -> 完全一致検索
      ((and (equal ?' (string-to-char (, query)))
	    (equal "'" (substring (, query) -1)))
       (prog1 (mapcar
	       (function
		(lambda (entry)
		  (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (xdic-search-multi-dictionaries (, dic-list) (substring (, query) 1 -1) 'lambda))
	 (goto-char (point-min))))
      ;; 検索語が // で囲まれている場合 -> 任意検索
      ((and (equal ?/ (string-to-char (, query)))
	    (equal "/" (substring (, query) -1)))
       (prog1 (mapcar
	       (function
		(lambda (entry)
		  (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (xdic-search-multi-dictionaries (, dic-list) (substring (, query) 1 -1) 0))
	 (goto-char (point-min))))
      ;; 検索語の先頭に * がある場合 -> 後方一致検索
      ((equal ?* (string-to-char (, query)))
       (prog1 (mapcar
	       (function
		(lambda (entry)
		  (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (xdic-search-multi-dictionaries (, dic-list) (substring (, query) 1) t))
	 (goto-char (point-min))))
      ;; 検索語の末尾に * がある場合 -> 前方一致検索
      ((equal "*" (substring (, query) -1))
       (prog1 (mapcar
	       (function
		(lambda (entry)
		  (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		  (car entry)))
	       (xdic-search-multi-dictionaries (, dic-list) (substring (, query) 0 -1)))
	 (goto-char (point-min))))
      ;; 特に指定がない場合 -> 指定された S 式を評価
      (t
       (,@ sexp)))))


;; 英和辞典を検索する関数
(defun xdic-search-english-dictionary (query)
  (or (xdic-decide-query-type xdic-eiwa-symbol-list query
	(let (word-list stem-list pattern original point)
	  (setq word-list (xdic-split-string query))
	  (prog1 (mapcar
		  (function
		   (lambda (entry)
		     (and (not point)
			  (string-match pattern (car entry))
			  (setq point (point)))
		     (xdic-insert-content (car entry)
					  (xdic-get-content (nth 1 entry) (nth 2 entry)))
		     (car entry)))
		  (prog1 (or
			  ;; (1) 不規則変化動詞を検索する
			  (and
			   (setq stem-list (assoc (car word-list) stem:irregular-verb-alist))
			   (apply
			    'append
			    (mapcar
			     (function
			      (lambda (word)
				(setq pattern (format "^%s\\( +\\w+\\)*$" (regexp-quote word)))
				(delq nil
				      (mapcar
				       (function
					(lambda (entry)
					  (and (string-match pattern (car entry))
					       (or original (setq original word))
					       entry)))
				       (xdic-search-multi-dictionaries xdic-eiwa-symbol-list
								       word)))))
			     (append (sort (cdr stem-list) 'string<)
				     (if (member (car word-list) (cdr stem-list))
					 nil
				       (list (car word-list)))))))
			  ;; (2) 不規則変化動詞を無視した stemming を行なって検索する
			  (progn
			    (setq stem-list (let ((stem:irregular-verb-alist nil))
					      (stem:stripping-suffix (car word-list))))
			    ;; 最長部分列を求める
			    (setq pattern (let* ((w1 (car stem-list))
						(w2 (car (reverse stem-list)))
						(i (min (length w1) (length w2))))
					   (while (not (string= (substring w1 0 i)
								(substring w2 0 i)))
					     (setq i (1- i)))
					   (substring w1 0 i)))
			    (delq nil
				  (mapcar
				   (function
				    (lambda (entry)
				      (if (string-match pattern (car entry)) entry)))
				   (prog1 (mapcar
					   (function
					    (lambda (entry)
					      ;; 検索結果から原形と推定される見出し語を検索
					      (and (member (car entry) stem-list)
						   (< (length original) (length (car entry)))
						   (setq original (car entry)))
					      entry))
					   (xdic-search-multi-dictionaries xdic-eiwa-symbol-list
									   pattern))
				     (if original
					 (setq pattern (if (string= original (car word-list))
							   (format "^%s\\( +\\w+\\)*$"
								   (regexp-quote original))
							 (format "^\\(%s\\|%s\\)\\( +\\w+\\)*$"
								   (regexp-quote original)
								   (regexp-quote (car word-list)))))
				       (setq original pattern
					     pattern (concat "^" (regexp-quote pattern)))
				       (message "Can't find original form of \"%s\""
						(car word-list))
				       ))))))
		    (setq pattern (if (nth 1 word-list)
				     (format "^%s +%s\\( +\\w+\\)*$"
					     (regexp-quote original)
					     (regexp-quote (nth 1 word-list)))
				   (format "^%s$" (regexp-quote original))))))
	    (goto-char (or point (point-min))))))
      (progn (message "Can't find word, \"%s\"." query) nil)))


;; 和英辞典を検索する関数
(defun xdic-search-japanese-dictionary (query)
  (or (xdic-decide-query-type xdic-waei-symbol-list query
	;; 特に指定がない場合 -> 前方一致検索
	(prog1 (mapcar
		(function
		 (lambda (entry)
		   (xdic-insert-content (car entry) (xdic-get-content (nth 1 entry) (nth 2 entry)))
		   (car entry)))
		(xdic-search-multi-dictionaries xdic-waei-symbol-list query))
	  (goto-char (point-min))))
      (progn (message "Can't find word, \"%s\"." query) nil)))




;;;----------------------------------------------------------------------
;;;		本体
;;;----------------------------------------------------------------------

(defun xdic-word-at-point () "\
カーソル位置の単語を返す関数"
  (save-excursion
    (if (not (looking-at "\\<")) (forward-word -1))
    (downcase (buffer-substring (point) (progn (forward-word 1) (point))))))


(defvar xdic-read-minibuffer-history '() "\
xdic-read-from-minibuffer 関数のヒストリ")
(defun xdic-read-from-minibuffer (&optional prompt init) "\
ミニバッファから単語を読みとる関数"
  (or init (setq init (or (xdic-word-at-point) "")))
  (setq xdic-read-minibuffer-history
	(cons init xdic-read-minibuffer-history))
  (downcase
   (read-from-minibuffer (or prompt "Input word : ") init
			 nil nil '(xdic-read-minibuffer-history . 1))))

;; 単語を辞書で調べる関数
(defun xdic-describe-word (word)
  "Display the meaning of word."
  (interactive (list (xdic-read-from-minibuffer)))
  (if (< (length word) 2)
      (setq word (xdic-read-from-minibuffer
		  (format "\"%s\" is too short word. Input word again : " word)
		  word)))
  (set-buffer (get-buffer-create xdic-buffer-name))
  (or (string= mode-name xdic-mode-name) (xdic-mode))
  (setq buffer-read-only nil)
  (erase-buffer)
  (let ((case-fold-search t))
    (if (if (string-match "\\cj" word)
	    (xdic-search-japanese-dictionary word)
	  (xdic-search-english-dictionary word))
	(progn
	  (setq buffer-read-only t)
	  (set-buffer-modified-p nil)
	  (xdic-display-buffer)
	  ))))


(defun xdic-describe-region (start end)
  "Display the meaning of pattern."
  (interactive (list (region-beginning) (region-end)))
  (xdic-describe-word (buffer-substring start end)))


(defun xdic-describe-word-at-point ()
  "Display the meaning of word at point in Japanese."
  (interactive)
  (xdic-describe-word (or (xdic-word-at-point)
			  (xdic-read-from-minibuffer))))


;;; 次の項目に移動する関数
(defun xdic-forward-item ()
  "Move point to the next item."
  (interactive)
  (let ((o))
    (goto-char (xdic-next-overlay-change
		(if (setq o (car (xdic-overlays-at (point))))
		    (xdic-overlay-end o)
		  (point))))))


;;; 前の項目に移動する関数
(defun xdic-backward-item ()
  "Move point to the previous item."
  (interactive)
  (let ((o))
    (goto-char (xdic-previous-overlay-change
		(xdic-previous-overlay-change
		 (if (setq o (car (xdic-overlays-at (point))))
		     (xdic-overlay-start o)
		   (xdic-previous-overlay-change (xdic-previous-overlay-change (point)))))))))


(defun xdic-goto-point-min () "\
バッファの先頭に移動する関数"
  (interactive)
  (goto-char (point-min)))


(defun xdic-goto-point-max () "\
バッファの末尾に移動する関数"
  (interactive)
  (goto-char (point-max)))


(defun xdic-display-buffer () "\
検索結果表示バッファを表示する関数"
  (interactive)
  (let ((w1 (selected-window))
	(w2 (get-buffer-window xdic-buffer-name)))
    (if w2 (select-window w2)
      (setq w2 (select-window (if (one-window-p)
				  (split-window w1 (- (window-height) xdic-window-height))
				(next-window))))
      (set-window-buffer w2 xdic-buffer-name))
    (set-window-start w2 (point))
    (if xdic-disable-select-window (select-window w1))))


(defun xdic-other-window () "\
検索表示バッファから元のバッファに戻る関数"
  (interactive)
  (let ((w (selected-window)))
    (if (and (string= (buffer-name (window-buffer w))
		      xdic-buffer-name)
	     (one-window-p))
	(progn
	  (split-window w (- (window-height) xdic-window-height))
	  (set-window-buffer w (other-buffer)))
      (other-window -1))))


(defun xdic-close-window () "\
検索表示バッファを表示しているウインドウを消去する関数"
  (interactive)
  (let ((w (get-buffer-window xdic-buffer-name)))
    (if w
	(cond
	 ((= (window-height w) xdic-window-height)
	  (delete-window w))
	 (t
	  (set-window-buffer w (other-buffer))
	  (select-window (next-window)))
	 ))))


(defun xdic-exit () "\
検索結果表示バッファを削除する関数"
  (interactive)
  (xdic-close-window)
  (kill-buffer xdic-buffer-name)
  (mapcar 'xdic-close-dictionary xdic-eiwa-symbol-list)
  (mapcar 'xdic-close-dictionary xdic-waei-symbol-list)
  (setq xdic-eiwa-symbol-list nil
	xdic-waei-symbol-list nil))


;;; 辞書を閲覧する major-mode
(defun xdic-mode () "\
辞書を閲覧するメジャーモード

\\{xdic-mode-map}
"
  (kill-all-local-variables)
  (make-local-variable 'fill-column)
  (setq major-mode 'xdic-mode
	mode-name   xdic-mode-name
	fill-column xdic-fill-column
	left-margin xdic-left-margin
	xdic-mode-map (make-keymap))
  ;; キーバインドの設定
  (define-key xdic-mode-map " " 'scroll-up)
  (define-key xdic-mode-map "b" 'scroll-down)
  (define-key xdic-mode-map [backspace] 'scroll-down)
  (define-key xdic-mode-map [delete] 'scroll-down)
  (define-key xdic-mode-map "\C-?" 'scroll-down)
  (define-key xdic-mode-map "n" 'xdic-forward-item)
  (define-key xdic-mode-map "\t" 'xdic-forward-item)
  (define-key xdic-mode-map "p" 'xdic-backward-item)
  (define-key xdic-mode-map "\M-\t" 'xdic-backward-item)
  (define-key xdic-mode-map "o" 'xdic-other-window)
  (define-key xdic-mode-map "q" 'xdic-close-window)
  (define-key xdic-mode-map "Q" 'xdic-exit)
  (define-key xdic-mode-map "w" 'xdic-describe-word)
  (define-key xdic-mode-map "<" 'xdic-goto-point-min)
  (define-key xdic-mode-map ">" 'xdic-goto-point-max)
  (define-key xdic-mode-map "?" 'describe-mode)
  (cond
   ((not xdic-disable-vi-key)
    (define-key xdic-mode-map "h" 'backward-char)
    (define-key xdic-mode-map "j" 'next-line)
    (define-key xdic-mode-map "k" 'previous-line)
    (define-key xdic-mode-map "l" 'forward-char)))
  (use-local-map xdic-mode-map)
  ;; 見出し語の face の設定
  (make-face 'xdic-face)
  (and (or (not (fboundp 'facep))
	   (facep xdic-face-style))
       (copy-face xdic-face-style 'xdic-face))
  (and window-system
       xdic-face-color
       (set-face-foreground 'xdic-face xdic-face-color))
  ;; それぞれの辞書を初期化する
  (or xdic-eiwa-symbol-list
      (setq xdic-eiwa-symbol-list (delq nil (mapcar 'xdic-init-dictionary xdic-eiwa-dictionary-list))))
  (setq xdic-eiwa-symbol-list (delq nil (mapcar 'xdic-open-dictionary xdic-eiwa-symbol-list)))
  (or xdic-waei-symbol-list
      (setq xdic-waei-symbol-list (delq nil (mapcar 'xdic-init-dictionary xdic-waei-dictionary-list))))
  (setq xdic-waei-symbol-list (delq nil (mapcar 'xdic-open-dictionary xdic-waei-symbol-list)))
  (run-hooks 'xdic-mode-hook))


;;; 1.6 との互換性を維持するための宣言
(defalias 'xdic:describe-word 'xdic-describe-word)
(defalias 'xdic:describe-word-at-point 'xdic-describe-word-at-point)




;;;----------------------------------------------------------------------
;;;		各種 Emacsen の違いを吸収する
;;;----------------------------------------------------------------------

(if (fboundp 'next-overlay-change)
    (defalias 'xdic-next-overlay-change 'next-overlay-change)
  ;; XEmacs の場合
  (defun xdic-next-overlay-change (pos) "\
Return the next position after POS where an extent starts or ends.
If there are no more extent boundaries after POS, return (point-max)."
    (catch 'found-next-extent
      (mapcar (function (lambda (ext)
			  (cond
			   ((> (extent-start-position ext) pos)
			    (throw 'found-next-extent (extent-start-position ext)))
			   ((> (extent-end-position ext) pos)
			    (throw 'found-next-extent (extent-end-position ext)))
			   )))
	      (extent-list))
      (point-max))))


(if (fboundp 'previous-overlay-change)
    (defalias 'xdic-previous-overlay-change 'previous-overlay-change)
  (if (fboundp 'extent-list)
      ;; XEmacs の場合
      (defun xdic-previous-overlay-change (pos) "\
Return the previous position before POS where an extent starts or ends.
If there are no more extent boundaries before POS, return (point-min)."
	(catch 'found-previous-extent
	  (mapcar (function (lambda (ext)
			      (cond
			       ((< (extent-end-position ext) pos)
				(throw 'found-previous-extent (extent-end-position ext)))
			       ((< (extent-start-position ext) pos)
				(throw 'found-previous-extent (extent-start-position ext)))
			       )))
		  (reverse (extent-list)))
	  (point-min)))
    ;; Emacs 19.34 以前の場合
    (defun xdic-previous-overlay-change (pos) "\
Return the previous position before POS where an overlay starts or ends.
If there are no more overlay boundaries before POS, return (point-min)."
      (if (> pos (point-max))
	  (error "Specified position is larger than point-max"))
      (save-excursion
	(let (next (prev (point-min)))
	  (while (> pos (setq next (xdic-next-overlay-change prev)))
	    (setq prev next))
	  prev)))))


(if (fboundp 'overlays-at)
    (defalias 'xdic-overlays-at 'overlays-at)
  (defun xdic-overlays-at (pos) "\
Return a list of the extents that contain position POS."
    (delq nil (mapcar (function (lambda (ext)
				  (and (<= (extent-start-position ext) pos)
				       (> (extent-end-position ext) pos)
				       ext)))
		      (extent-list)))))


(if (fboundp 'overlay-put)
    (defalias 'xdic-overlay-put 'overlay-put)
  (defalias 'xdic-overlay-put 'set-extent-property))


(if (fboundp 'make-overlay)
    (defalias 'xdic-make-overlay 'make-overlay)
  (defalias 'xdic-make-overlay 'make-extent))


(if (fboundp 'overlay-start)
    (defalias 'xdic-overlay-start 'overlay-start)
  (defalias 'xdic-overlay-start 'extent-start-position))


(if (fboundp 'overlay-end)
    (defalias 'xdic-overlay-end 'overlay-end)
  (defalias 'xdic-overlay-end 'extent-end-position))


(if (fboundp 'match-string)
    (defalias 'xdic-match-string 'match-string)
  ;; Introduced in Emacs 19.29.
  (defun xdic-match-string (num &optional string) "\
Return string of text matched by last search.
NUM specifies which parenthesized expression in the last regexp.
Value is nil if NUMth pair didn't match, or there were less than NUM pairs.
Zero means the entire text matched by the whole regexp or whole string.
STRING should be given if the last search was by `string-match' on STRING."
    (if (match-beginning num)
	(if string
	    (substring string (match-beginning num) (match-end num))
	  (buffer-substring (match-beginning num) (match-end num))))))


(defun xdic-split-string (string &optional separators) "\
Splits STRING into substrings where there are matches for SEPARATORS.
Each match for SEPARATORS is a splitting point.
The substrings between the splitting points are made into a list
which is returned.
If SEPARATORS is absent, it defaults to \"[ \\f\\t\\n\\r\\v]+\".

If there is match for SEPARATORS at the beginning of STRING, we do not
include a null substring for that.  Likewise, if there is a match
at the end of STRING, we don't include a null substring for that."
  (or separators (setq separators "[ \f\t\n\r\v]+"))
  (let (list (start 0))
    (while (string-match separators string start)
      (or (= start (match-beginning 0))
	  (setq list (cons (substring string start (match-beginning 0)) list)))
      (setq start (match-end 0)))
    (reverse (if (= start (length string)) list (cons (substring string start) list)))))


(defvar xdic-left-margin-ignored-by-fill-region (string-match "^19\\.28" emacs-version) "\
fill-region 関数が left-margin の設定を無視する場合は nil 以外を設定する")
(defun xdic-fill-region (start end) "\
Standarized fill-region.
fill-region の Emacs のバージョンによって異なる動作を標準化する関数"
  (save-match-data
    (if xdic-left-margin-ignored-by-fill-region
	;; Emacs-19.28 附属の fill-region は、left-margin を無視するので強制的に indent する
	(let ((fill-column (- fill-column xdic-left-margin)))
	  (fill-region start end)
	  (indent-region start (point) xdic-left-margin))
      (fill-region start end))
    (save-excursion			; 余分な空行を削除する
      (beginning-of-line)
      (if (looking-at "^[ \t]*$")
	  (delete-region (1- (point)) (match-end 0)))
      )))


(defun xdic-insert-file-contents (filename &optional visit beg end replace coding-system)
  (let ((coding-system-for-read coding-system)
	(file-coding-system-for-read coding-system))
    (insert-file-contents filename visit beg end replace)))


(defun xdic-call-process (program &optional infile buffer display coding-system &rest args)
  (let ((coding-system-for-read coding-system)
	(coding-system-for-write coding-system)
	(process-input-coding-system coding-system)
	(process-output-coding-system coding-system)
	(default-process-coding-system (cons coding-system coding-system)))
    (apply 'call-process program infile buffer display args)))
