;;; xdic.el ---- major mode to view dictionary
;;; $Id$

;;; Author: Tsuchiya Masatoshi <tsuchiya@pine.kuee.kyoto-u.ac.jp>
;;; Keywords: dictionary

;;; Commentary:

;; 英和辞書を閲覧する目的で作成した major mode です。
;; 利用及び再配布の際は、GNU 一般公用許諾書の適当なバージョンにしたがっ
;; て下さい。

;; 一次配布元
;;    http://www-nagao.kuee.kyoto-u.ac.jp/member/tsuchiya/elisp/xdic.html


;;; ※※※ 注意 ※※※

;; このプログラムは、まだ作成されたばかりですので、これから多数の変更
;; が出ると思われます。注意して使ってください。
;;
;; また、こんな機能が欲しいとか、動作が希望と違うなど、要望があれば遠
;; 慮なく連絡してください。出来るだけ対応したいと思います。


;;; How to Install

;;	(1) xdic.el と stem.el を適当な場所に保存して下さい。必要なら
;;	    バイトコンパイルして下さい。
;;	(2) 辞書を検索するために look を呼び出しています。パスが通って
;;	    いるか確認して下さい。
;;	(3) 辞書を変換して、適当な場所に保存して下さい。
;;	    xdic.el は、辞書のそれぞれのレコードが1つの見出し語と1つの
;;	    説明文からなり、かつ見出し語と説明文がタブで区切られている
;;	    ことを要求します。
;;	(4) .emacs に次のようなコードを挿入します。
;;
;;		(autoload 'xdic-describe-word "xdic" "英単語の意味を調べる" t nil)
;;		(global-set-key "\C-cw" 'xdic-describe-word)
;;
;;	    好みに合わせて適当にキーバインドは変更して下さい。

;; Emacs20 で使う場合は、
;;
;;		(set-language-environment "Japanese")
;;		(set-terminal-coding-system 'euc-japan)
;;
;; と .emacs に設定されているか確認してください。

(provide 'xdic)
(require 'stem)



;;;----------------------------------------------------------------------
;;;		カスタマイズ用変数
;;;----------------------------------------------------------------------

(defvar xdic-eiwa-dictionary-file-name (expand-file-name "~/usr/lib/elisp/gene.dic") "\
*Path of the English-to-Japanese dictionary.
英和辞書のファイル名")

(defvar xdic-waei-dictionary-file-name (expand-file-name "~/usr/lib/elisp/jgene.dic") "\
*Path of the Japanese-to-English dictionary.
和英辞書のファイル名")

(defvar xdic-left-margin 2 "*Left margin of contents.
説明文の左側の余白幅")

(defvar xdic-fill-column default-fill-column "*Right edge of contents.
説明文を整形する幅")

(defvar xdic-window-height 10 "*Height of window to show entrys and contents.
検索結果表示ウインドウの高さ")

(defvar xdic-disable-select-window nil "*Option to disable to select other window.
検索結果表示ウインドウにカーソルを移動しないようにする場合は nil 以外を設定する")

(defvar xdic-face-style 'bold  "*Style of entry.
見出し語を表示するために使う装飾形式")

(defvar xdic-face-color "black" "*Color of entry.
見出し語を表示するために使う色")

(defvar xdic-disable-vi-key nil "*Option to disable some key.
辞書閲覧に vi ライクのキーを使わない場合は nil 以外を設定する")


(defvar xdic-mode-map nil)
(defconst xdic-version "1.7alpha3")
(defconst xdic-buffer-name "*xdic*" "検索結果表示バッファの名前")
(defconst xdic-mode-name "Xdic" "検索結果を表示するバッファの major mode")




;;;----------------------------------------------------------------------
;;;		検索メソッドを呼び出す関数
;;;----------------------------------------------------------------------

(defun xdic-open-dictionary (dic) "\
Function to open dictionary.
指定された辞書と関連付けられている検索ライブラリを初期化する関数
"
  (if (file-readable-p (get dic 'file-name))
      (if (require (get dic 'search-method))
	  (funcall (get (get dic 'search-method) 'open-dictionary) dic))
    (message "Can't find file, \"%s\"." (get dic 'file-name))
    nil))


(defun xdic-close-dictionary (dic) "\
Function to close dictionary.
指定された辞書と関連付けられている検索ライブラリを終了する関数
"
  (funcall (get (get dic 'search-method) 'close-dictionary) dic))


(defun xdic-search-entry (dic word &optional search-type) "\
Function to search word in dictionary.
指定されている辞書と関連付けられている検索関数を呼び出す関数
"
  (funcall (get (get dic 'search-method) 'search-entry) dic word search-type))


(defun xdic-get-content (dic id) "\
Function to get content.
指定されている辞書から定義文を読み出す関数
"
  (funcall (get (get dic 'search-method) 'get-content) dic id))




;;;----------------------------------------------------------------------
;;;		内部関数
;;;----------------------------------------------------------------------

;;; 見出し語と定義文を整形しながら挿入する
(defun xdic-insert-content (word content)
  (overlay-put (xdic-make-overlay (point) (progn (insert word) (point))) 'face 'xdic-face)
  (insert "\n")
  (xdic-fill-region (point) (progn (insert content) (point)))
  (insert "\n"))


;;; 英和辞典を検索する関数
(defvar xdic-english-prep-list '("at" "by" "for" "in" "on" "of" "with")
  "List of English prepositions")

(defvar xdic-english-prep-regexp
  (format "[ \t\r\f\n]+\\(%s\\)$" (mapconcat 'regexp-quote xdic-english-prep-list "\\|"))
  "Regexp of Englist prepositions")

(defun xdic-search-english-dictionary (query)
  (or (cond
       ;; 検索語の末尾に * がある場合 -> 前方一致検索
       ((string= "*" (substring query -1))
	(if (mapcar '(lambda (entry)
		       (xdic-insert-content (car entry)
					    (xdic-get-content xdic-eiwa-dictionary (cdr entry))))
		    (xdic-search-entry xdic-eiwa-dictionary (substring query 0 -1)))
	    (goto-char (point-min))))
       ;; 検索語の先頭に * がある場合 -> 後方一致検索
       ((string= "*" (substring query 0 1))
	(if (mapcar '(lambda (entry)
		       (xdic-insert-content (car entry)
					    (xdic-get-content xdic-eiwa-dictionary (cdr entry))))
		    (xdic-search-entry xdic-eiwa-dictionary (substring query 1) t))
	    (goto-char (point-min))))
       ;; それ以外 -> stemming して検索
       (t
	(let (prep word stem-list entry-alist original point)
	  ;; 検索 query が前置詞を含んでいるか調べる
	  (setq word (if (string-match xdic-english-prep-regexp query)
			 (progn
			   (setq prep (format "\\b%s\\b" (regexp-quote (xdic-match-string 1 query))))
			   (substring query 0 (match-beginning 0)))
		       query))
	  (setq stem-list (stem:stripping-suffix word))
	  (if (setq entry-alist (xdic-search-entry xdic-eiwa-dictionary (car stem-list)))
	      (progn
		(setq original
		      (concat "^" (regexp-quote
				   (catch 'stem
				     ;; 原形を探す
				     (mapcar '(lambda (s)
						(if (assoc s entry-alist) (throw 'stem s)))
					     stem-list)
				     (message "Can't find original form of \"%s\"." word)
				     (car stem-list)))))
		(mapcar '(lambda (entry)
			   ;; 原形と語頭が一致する見出し語を表示する
			   (if (string-match original (car entry))
			       (progn
				 ;; 前置詞が一致する見出し語を記録する
				 (and prep
				      (string-match prep (car entry))
				      (not point)
				      (setq point (point)))
				 (xdic-insert-content
				  (car entry)
				  (xdic-get-content xdic-eiwa-dictionary (cdr entry))))))
			entry-alist)
		(goto-char (or point (point-min))))
	    (setq query (format "%s\" or \"%s" query (car stem-list)))
	    nil))))
      (progn (message "Can't find word, \"%s\"." query) nil)))


;;; 和英辞典を検索する関数
(defun xdic-search-japanese-dictionary (query)
  (or (cond
       ;; 検索語の末尾に * がある場合 -> 前方一致検索
       ((string= "*" (substring query -1))
	(if (mapcar '(lambda (entry)
		       (xdic-insert-content (car entry)
					    (xdic-get-content xdic-waei-dictionary (cdr entry))))
		    (xdic-search-entry xdic-waei-dictionary (substring query 0 -1)))
	    (goto-char (point-min))))
       ;; 検索語の先頭に * がある場合 -> 後方一致検索
       ((string= "*" (substring query 0 1))
	(if (mapcar '(lambda (entry)
		       (xdic-insert-content (car entry)
					    (xdic-get-content xdic-waei-dictionary (cdr entry))))
		    (xdic-search-entry xdic-waei-dictionary (substring query 1) t))
	    (goto-char (point-min))))
       ;; それ以外 -> 前方一致検索
       (t
	(if (mapcar '(lambda (entry)
		       (xdic-insert-content (car entry)
					    (xdic-get-content xdic-waei-dictionary (cdr entry))))
		    (xdic-search-entry xdic-waei-dictionary query))
	    (goto-char (point-min)))))
      (progn (message "Can't find word, \"%s\"." query) nil)))




;;;----------------------------------------------------------------------
;;;		本体
;;;----------------------------------------------------------------------

(defun xdic-word-at-point () "\
カーソル位置の英単語を返す関数"
  (save-excursion
    (if (not (looking-at "\\<"))
        (forward-word -1))
    (if (looking-at "[A-Za-z]+")
	(downcase (buffer-substring (match-beginning 0) (match-end 0))))))


(defvar xdic-read-minibuffer-history '() "\
xdic-read-from-minibuffer 関数のヒストリ")
(defun xdic-read-from-minibuffer (&optional prompt init) "\
ミニバッファから英単語を読みとる関数"
  (or init (setq init (or (xdic-word-at-point) "")))
  (setq xdic-read-minibuffer-history
	(cons init xdic-read-minibuffer-history))
  (downcase
   (read-from-minibuffer (or prompt "Input word : ") init
			 nil nil '(xdic-read-minibuffer-history . 1))))


;;; 単語を辞書で調べる関数
(defun xdic-describe-word (word)
  "Display the meaning of word."
  (interactive (list (xdic-read-from-minibuffer)))
  (if (< (length word) 2)
      (setq word (xdic-read-from-minibuffer
		  (format "\"%s\" is too short word. Input word again : " word)
		  word)))
  (set-buffer (get-buffer-create xdic-buffer-name))
  (or (string= mode-name xdic-mode-name) (xdic-mode))
  (setq buffer-read-only nil)
  (erase-buffer)
  (let ((case-fold-search t))
    (if (if (string-match "\\cj" word)
	    (xdic-search-japanese-dictionary word)
	  (xdic-search-english-dictionary word))
	(progn
	  (setq buffer-read-only t)
	  (set-buffer-modified-p nil)
	  (xdic-display-buffer)
	  ))))


(defun xdic-describe-word-at-point ()
  "Display the meaning of word at point in Japanese."
  (interactive)
  (xdic-describe-word (or (xdic-word-at-point)
			  (xdic-read-from-minibuffer))))


;;; 次の項目に移動する関数
(defun xdic-forward-item ()
  "Move point to the next item."
  (interactive)
  (let ((o))
    (goto-char (xdic-next-overlay-change
		(if (setq o (car (xdic-overlays-at (point))))
		    (xdic-overlay-end o)
		  (point))))))


;;; 前の項目に移動する関数
(defun xdic-backward-item ()
  "Move point to the previous item."
  (interactive)
  (let ((o))
    (goto-char (xdic-previous-overlay-change
		(xdic-previous-overlay-change
		 (if (setq o (car (xdic-overlays-at (point))))
		     (xdic-overlay-start o)
		   (xdic-previous-overlay-change (xdic-previous-overlay-change (point)))))))))


(defun xdic-goto-point-min () "\
バッファの先頭に移動する関数"
  (interactive)
  (goto-char (point-min)))


(defun xdic-goto-point-max () "\
バッファの末尾に移動する関数"
  (interactive)
  (goto-char (point-max)))


(defun xdic-display-buffer () "\
検索結果表示バッファを表示する関数"
  (interactive)
  (let ((w1 (selected-window))
	(w2 (get-buffer-window xdic-buffer-name)))
    (if w2 (select-window w2)
      (setq w2 (select-window (if (one-window-p)
				  (split-window w1 (- (window-height) xdic-window-height))
				(next-window))))
      (set-window-buffer w2 xdic-buffer-name))
    (set-window-start w2 (point))
    (if xdic-disable-select-window (select-window w1))))


(defun xdic-other-window () "\
検索表示バッファから元のバッファに戻る関数"
  (interactive)
  (let ((w (selected-window)))
    (if (and (string= (buffer-name (window-buffer w))
		      xdic-buffer-name)
	     (one-window-p))
	(progn
	  (split-window w (- (window-height) xdic-window-height))
	  (set-window-buffer w (other-buffer)))
      (other-window -1))))


(defun xdic-close-window () "\
検索表示バッファを表示しているウインドウを消去する関数"
  (interactive)
  (let ((w (get-buffer-window xdic-buffer-name)))
    (if w
	(cond
	 ((= (window-height w) xdic-window-height)
	  (delete-window w))
	 (t
	  (set-window-buffer w (other-buffer))
	  (select-window (next-window)))
	 ))))


(defun xdic-kill-window () "\
検索結果表示バッファを削除する関数"
  (interactive)
  (xdic-close-window)
  (kill-buffer xdic-buffer-name))


;;; 辞書を閲覧する major-mode
(defun xdic-mode () "\
辞書を閲覧するメジャーモード

\\{xdic-mode-map}
"
  (kill-all-local-variables)
  (make-local-variable 'fill-column)
  (setq major-mode 'xdic-mode
	mode-name   xdic-mode-name
	fill-column xdic-fill-column
	left-margin xdic-left-margin
	xdic-mode-map (make-keymap))
  ;; キーバインドの設定
  (define-key xdic-mode-map " " 'scroll-up)
  (define-key xdic-mode-map "b" 'scroll-down)
  (define-key xdic-mode-map [backspace] 'scroll-down)
  (define-key xdic-mode-map [delete] 'scroll-down)
  (define-key xdic-mode-map "\C-?" 'scroll-down)
  (define-key xdic-mode-map "n" 'xdic-forward-item)
  (define-key xdic-mode-map "\t" 'xdic-forward-item)
  (define-key xdic-mode-map "p" 'xdic-backward-item)
  (define-key xdic-mode-map "\M-\t" 'xdic-backward-item)
  (define-key xdic-mode-map "o" 'xdic-other-window)
  (define-key xdic-mode-map "q" 'xdic-close-window)
  (define-key xdic-mode-map "Q" 'xdic-kill-window)
  (define-key xdic-mode-map "w" 'xdic-describe-word)
  (define-key xdic-mode-map "<" 'xdic-goto-point-min)
  (define-key xdic-mode-map ">" 'xdic-goto-point-max)
  (define-key xdic-mode-map "?" 'describe-mode)
  (cond
   ((not xdic-disable-vi-key)
    (define-key xdic-mode-map "h" 'backward-char)
    (define-key xdic-mode-map "j" 'next-line)
    (define-key xdic-mode-map "k" 'previous-line)
    (define-key xdic-mode-map "l" 'forward-char)))
  (use-local-map xdic-mode-map)
  ;; 見出し語の face の設定
  (make-face 'xdic-face)
  (and (or (not (fboundp 'facep))
	   (facep xdic-face-style))
       (copy-face xdic-face-style 'xdic-face))
  (and window-system
       xdic-face-color
       (set-face-foreground 'xdic-face xdic-face-color))
  (run-hooks 'xdic-mode-hook))




;;;----------------------------------------------------------------------
;;;		初期化
;;;----------------------------------------------------------------------

(defvar xdic-eiwa-dictionary
  (let ((s (make-symbol "eiwa")))
    (put s 'file-name xdic-eiwa-dictionary-file-name)
    (put s 'coding-system (if (>= emacs-major-version 20) 'euc-japan *euc-japan*))
    (put s 'search-method 'xdic-unix)
    s)
  "英和辞書の属性リスト")
(xdic-open-dictionary xdic-eiwa-dictionary)

(defvar xdic-waei-dictionary
  (let ((s (make-symbol "waei")))
    (put s 'file-name xdic-waei-dictionary-file-name)
    (put s 'coding-system (if (>= emacs-major-version 20) 'euc-japan *euc-japan*))
    (put s 'search-method 'xdic-unix)
    s)
  "和英辞書の属性リスト")
(xdic-open-dictionary xdic-waei-dictionary)



;;; 1.6 との互換性を維持するための宣言
(defalias 'xdic:describe-word 'xdic-describe-word)
(defalias 'xdic:describe-word-at-point 'xdic-describe-word-at-point)




;;;----------------------------------------------------------------------
;;;		各種 Emacsen の違いを吸収する
;;;----------------------------------------------------------------------

(if (fboundp 'next-overlay-change)
    (defalias 'xdic-next-overlay-change 'next-overlay-change)
  ;; XEmacs の場合
  (defun xdic-next-overlay-change (pos) "\
Return the next position after POS where an extent starts or ends.
If there are no more extent boundaries after POS, return (point-max)."
    (catch 'found-next-extent
      (mapcar (function (lambda (ext)
			  (cond
			   ((> (extent-start-position ext) pos)
			    (throw 'found-next-extent (extent-start-position ext)))
			   ((> (extent-end-position ext) pos)
			    (throw 'found-next-extent (extent-end-position ext)))
			   )))
	      (extent-list))
      (point-max))))


(if (fboundp 'previous-overlay-change)
    (defalias 'xdic-previous-overlay-change 'previous-overlay-change)
  (if (fboundp 'extent-list)
      ;; XEmacs の場合
      (defun xdic-previous-overlay-change (pos) "\
Return the previous position before POS where an extent starts or ends.
If there are no more extent boundaries before POS, return (point-min)."
	(catch 'found-previous-extent
	  (mapcar (function (lambda (ext)
			      (cond
			       ((< (extent-end-position ext) pos)
				(throw 'found-previous-extent (extent-end-position ext)))
			       ((< (extent-start-position ext) pos)
				(throw 'found-previous-extent (extent-start-position ext)))
			       )))
		  (reverse (extent-list)))
	  (point-min)))
    ;; Emacs 19.34 以前の場合
    (defun xdic-previous-overlay-change (pos) "\
Return the previous position before POS where an overlay starts or ends.
If there are no more overlay boundaries before POS, return (point-min)."
      (if (> pos (point-max))
	  (error "Specified position is larger than point-max"))
      (save-excursion
	(let (next (prev (point-min)))
	  (while (> pos (setq next (xdic-next-overlay-change prev)))
	    (setq prev next))
	  prev)))))


(if (fboundp 'overlays-at)
    (defalias 'xdic-overlays-at 'overlays-at)
  (defun xdic-overlays-at (pos) "\
Return a list of the extents that contain position POS."
    (delq nil (mapcar (function (lambda (ext)
				  (and (<= (extent-start-position ext) pos)
				       (> (extent-end-position ext) pos)
				       ext)))
		      (extent-list)))))


(if (fboundp 'overlay-put)
    (defalias 'xdic-overlay-put 'overlay-put)
  (defalias 'overlay-put 'set-extent-property))


(if (fboundp 'make-overlay)
    (defalias 'xdic-make-overlay 'make-overlay)
  (defalias 'xdic-make-overlay 'make-extent))


(if (fboundp 'overlay-start)
    (defalias 'xdic-overlay-start 'overlay-start)
  (defalias 'xdic-overlay-start 'extent-start-position))


(if (fboundp 'overlay-end)
    (defalias 'xdic-overlay-end 'overlay-end)
  (defalias 'xdic-overlay-end 'extent-end-position))


(if (fboundp 'match-string)
    (defalias 'xdic-match-string 'match-string)
  ;; Introduced in Emacs 19.29.
  (defun xdic-match-string (num &optional string) "\
Return string of text matched by last search.
NUM specifies which parenthesized expression in the last regexp.
Value is nil if NUMth pair didn't match, or there were less than NUM pairs.
Zero means the entire text matched by the whole regexp or whole string.
STRING should be given if the last search was by `string-match' on STRING."
    (if (match-beginning num)
	(if string
	    (substring string (match-beginning num) (match-end num))
	  (buffer-substring (match-beginning num) (match-end num))))))


(if (fboundp 'split-string)
    (defalias 'xdic-split-string 'split-string)
  (defun split-string (string &optional separators) "\
Splits STRING into substrings where there are matches for SEPARATORS.
Each match for SEPARATORS is a splitting point.
The substrings between the splitting points are made into a list
which is returned.
If SEPARATORS is absent, it defaults to \"[ \\f\\t\\n\\r\\v]+\".

If there is match for SEPARATORS at the beginning of STRING, we do not
include a null substring for that.  Likewise, if there is a match
at the end of STRING, we don't include a null substring for that."
      (let ((rexp (or separators "[ \f\t\n\r\v]+"))
	    (start 0)
	    notfirst
	    (list nil))
	(while (and (string-match rexp string
				  (if (and notfirst
					   (= start (match-beginning 0))
					   (< start (length string)))
				      (1+ start) start))
		    (< (match-beginning 0) (length string)))
	  (setq notfirst t)
	  (or (eq (match-beginning 0) 0)
	      (and (eq (match-beginning 0) (match-end 0))
		   (eq (match-beginning 0) start))
	      (setq list
		    (cons (substring string start (match-beginning 0))
			  list)))
	  (setq start (match-end 0)))
	(or (eq start (length string))
	    (setq list
		  (cons (substring string start)
			list)))
	(nreverse list))))


(defvar xdic-left-margin-ignored-by-fill-region (string-match "^19\\.28" emacs-version) "\
fill-region 関数が left-margin の設定を無視する場合は nil 以外を設定する")
(defun xdic-fill-region (start end) "\
Standarized fill-region.
fill-region の Emacs のバージョンによって異なる動作を標準化する関数"
  (save-match-data
    (if xdic-left-margin-ignored-by-fill-region
	;; Emacs-19.28 附属の fill-region は、left-margin を無視するので強制的に indent する
	(let ((fill-column (- fill-column xdic-left-margin)))
	  (fill-region start end)
	  (indent-region start (point) xdic-left-margin))
      (fill-region start end))
    (save-excursion			; 余分な空行を削除する
      (beginning-of-line)
      (if (looking-at "^[ \t]*$")
	  (delete-region (1- (point)) (match-end 0)))
      )))


(defun xdic-insert-file-contents (filename &optional visit beg end replace coding-system)
  (let ((coding-system-for-read coding-system)
	(file-coding-system-for-read coding-system))
    (insert-file-contents filename visit beg end replace)))


(defun xdic-call-process (program &optional infile buffer display coding-system &rest args)
  (let ((coding-system-for-read coding-system)
	(coding-system-for-write coding-system)
	(process-input-coding-system coding-system)
	(process-output-coding-system coding-system)
	(default-process-coding-system (cons coding-system coding-system)))
    (apply 'call-process program infile buffer display args)))
